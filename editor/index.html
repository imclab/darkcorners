<!DOCTYPE html>
<html lang="en">
<head>
	<title>Level Editor for Dark Corners</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body { color: #ccc; background-color: #333; }
		canvas { background-color: #ccc; position: relative; }
		#thumbs { float: left; margin-right: 10px; }
		#exported { display: none; width: 640px; height: 480px; }
	</style>
	<script src="../libs/dat.gui.min.js"></script>
	<script src="../assets/assets.js"></script>
	<script src="../js/map.js"></script>
</head>
<body>
	<h3>Level editor</h3>
	<canvas id="canvas" width="640", height="640">
		<p>Oh noes, no &lt;canvas&gt;!</p>
	</canvas>
	<p>Left click to draw walls or place selected thing. Right click to erase.</p>
	<textarea id="exported"></textarea>
	<p>Material reference: hover over the image to see the name to put to the map properties.<p>
	<p>Currently you can't click them and the material cannot be set for individual tiles.</p>
	<table id="thumbs"></table>

	<script>
		window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
		var hashParams = (function() {
			var params = {}, param;
			var q = window.location.hash.replace('#', '').split('&');
			for (var i = 0; i < q.length; ++i) {
				param = q[i].split('=');
				params[param[0]] = param[1];
			}
			return params;
		})();

		var canvas = document.getElementById("canvas");
		var w = 40, h = 40;
		var s = canvas.width / w;
		var ctx = canvas.getContext("2d");
		ctx.font = "bolder " + ((s*0.9)|0) + "px monospace";
		ctx.textBaseline = "middle";
		ctx.textAlign = "center";

		var i;

		var editor = {
			drawGrid: true,
			drawTextures: false,
			hideLights: false,
			hideObjects: false
		};

		var level = {
			materials: {
				ceiling: "rock-01",
				wall: "stone-01",
				floor: "stone-floor-01"
			},
			roomHeight: 3,
			gridSize: 2,
			objects: [],
			lights: [],
			start: [ Math.floor(w*0.3)-0.5, Math.floor(h/2)-0.5 ],
			startAngle: 0,
			exit: [ Math.floor(w*0.7)-0.5, Math.floor(h/2)-0.5 ],
			width: w,
			depth: h,
			map: new Map(w, h, OPEN)
		};
		if (hashParams.level)
			importLevel(hashParams.level);


		var materials = [ "rock-01", "rock-02", "rock-03", "rock-04", "sand-01", "sand-02", "sand-03", "sand-04", "stone-01", "stone-02", "stone-03", "stone-floor-01", "stone-floor-02", "stone-floor-03", "stone-floor-04", "stone-floor-05", "stone-floor-06", "tiles-01", "tiles-02", "wood-floor-01" ];
		var gtemplate = '<td><img id="%1" src="../assets/textures/thumbs/%1.jpg" width="64" height="64" alt="%1" title="%1"></img></td>';
		var gcols = 10;
		var gallery = "";
		for (i = 0; i < materials.length; ++i) {
			if (i % gcols === 0) gallery += '<tr>';
			gallery += gtemplate.replace(/%1/g, materials[i]);
			if (i % gcols == gcols-1) gallery += '</tr>';
		}
		document.getElementById("thumbs").innerHTML = gallery;
		var images = {};
		for (i = 0; i < materials.length; ++i)
			images[materials[i]] = document.getElementById(materials[i]);

		var objects = [];
		for (i in assets.objects) objects.push(i);
		var tools = {};

		tools.walls = {
			drawing: null,
			drawWalls: function() { currentTool = tools.walls; },
			mousedown: function(e) {
				if (e.button == 0) tools.walls.drawing = WALL;
				else if (e.button == 2) tools.walls.drawing = OPEN;
				else return;
				putMouse(e._x, e._y, tools.walls.drawing);
			},
			mousemove: function(e) {
				if (tools.walls.drawing) putMouse(e._x, e._y, tools.walls.drawing);
			},
			mouseup: function(e) {
				tools.walls.drawing = null;
			}
		};
		var currentTool = tools.walls;

		tools.diagonals = {
			placeDiagonalWalls: function() { currentTool = tools.diagonals; },
			mousedown: function(e) {
				if (e.button == 2) putMouse(e._x, e._y, OPEN);
				else if (e.button == 0) {
					var c = 0;
					if (getMouse(e._x - s, e._y) == WALL) ++c;
					if (getMouse(e._x + s, e._y) == WALL) ++c;
					if (getMouse(e._x, e._y - s) == WALL) ++c;
					if (getMouse(e._x, e._y + s) == WALL) ++c;
					if (c == 2) putMouse(e._x, e._y, DIAG);
				}
			},
		};

		tools.start = {
			placeStart: function() { currentTool = tools.start; },
			mousedown: function(e) {
				if (e.button == 0) {
					putMouse(e._x, e._y, OPEN);
					level.start[0] = e._x / s;
					level.start[1] = e._y / s;
				}
			}
		};

		tools.exit = {
			placeExit: function() { currentTool = tools.exit; },
			mousedown: function(e) {
				if (e.button == 0) {
					putMouse(e._x, e._y, OPEN);
					level.exit[0] = e._x / s;
					level.exit[1] = e._y / s;
				}
			}
		};

		tools.light = {
			addLight: function() { currentTool = tools.light; },
			mousedown: function(e) {
				if (e.button == 0) {
					level.lights.push({ position: { x: e._x / s, z: e._y / s } });
				} else if (e.button == 2) {
					for (var i = 0; i < level.lights.length; ++i) {
						if (Math.abs(level.lights[i].position.x - e._x / s) < 0.75 &&
							Math.abs(level.lights[i].position.z - e._y / s) < 0.75) {
								level.lights.splice(i, 1);
								break;
						}
					}
				}
			}
		};

		tools.object = {
			object: "barrel",
			addObject: function() { currentTool = tools.object; },
			mousedown: function(e) {
				if (e.button == 0) {
					level.objects.push({
						name: tools.object.object,
						position: { x: e._x / s, z: e._y / s }
					});
				} else if (e.button == 2) {
					for (var i = 0; i < level.objects.length; ++i) {
						if (Math.abs(level.objects[i].position.x - e._x / s) < 0.75 &&
							Math.abs(level.objects[i].position.z - e._y / s) < 0.75) {
								level.objects.splice(i, 1);
								break;
						}
					}
				}
			}
		};

		function putMouse(x, y, what) {
			x = Math.floor(x / s);
			y = Math.floor(y / s);
			level.map.put(x, y, what);
		}

		function getMouse(x, y, fallback) {
			x = Math.floor(x / s);
			y = Math.floor(y / s);
			return level.map.get(x, y, fallback);
		}

		function render() {
			requestAnimationFrame(render);
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			var i, j, cell;
			// Grid and walls
			ctx.strokeStyle = "#999";
			ctx.fillStyle = "#640";
			for (j = 0; j < h; ++j) {
				for (i = 0; i < w; ++i) {
					cell = level.map.get(i, j);
					if (cell == DIAG) ctx.globalAlpha = 0.5;
					else ctx.globalAlpha = 1.0;
					if (editor.drawTextures) {
						if (cell == WALL || cell == DIAG)
							ctx.drawImage(images[level.materials.wall], i * s, j * s, s, s);
						else ctx.drawImage(images[level.materials.floor], i * s, j * s, s, s);
					} else {
						if (cell == WALL || cell == DIAG)
							ctx.fillRect(i * s, j * s, s, s);
					}
					if (editor.drawGrid)
						ctx.strokeRect(i * s, j * s, s, s);
				}
			}
			// Lights
			if (!editor.hideLights) {
				ctx.fillStyle = "#ff0";
				for (i = 0; i < level.lights.length; ++i) {
					ctx.beginPath();
					ctx.arc(level.lights[i].position.x * s, level.lights[i].position.z * s, s * 0.25, 0, Math.PI * 2);
					ctx.fill();
				}
			}
			// Objects
			if (!editor.hideObjects) {
				ctx.fillStyle = "#006";
				for (i = 0; i < level.objects.length; ++i) {
					ctx.beginPath();
					ctx.arc(level.objects[i].position.x * s, level.objects[i].position.z * s, s * 0.4, 0, Math.PI * 2);
					ctx.fill();
				}
			}
			// Start
			ctx.fillStyle = "#229";
			ctx.fillRect(level.start[0] * s + 1 - s/2, level.start[1] * s + 1 - s/2, s - 2, s - 2);
			ctx.fillStyle = "#66f";
			ctx.fillText("S", level.start[0] * s, level.start[1] * s);
			// Exit
			ctx.fillStyle = "#922";
			ctx.fillRect(level.exit[0] * s + 1 - s/2, level.exit[1] * s + 1 - s/2, s - 2, s - 2);
			ctx.fillStyle = "#f66";
			ctx.fillText("E", level.exit[0] * s, level.exit[1] * s);
		}

		function prepareExport() {
			var errors = [];
			// Fill floor
			level.map.replace(OPEN, VOID);
			level.map.fill(Math.floor(level.start[0]), Math.floor(level.start[1]), VOID, OPEN, DIAG);
			// Check for unreachable exit
			if (level.map.get(Math.floor(level.exit[0]), Math.floor(level.exit[1])) != OPEN)
				errors.push("Error: Exit is unreachable!");
			// Check for reaching the borders
			var closed = true;
			for (var i = 0; i < w; ++i) {
				if (level.map.get(i, 0) == OPEN) { closed = false; break; }
				if (level.map.get(i, h-1) == OPEN) { closed = false; break; }
			}
			if (closed) {
				for (var j = 0; j < h; ++j) {
					if (level.map.get(0, j) == OPEN) { closed = false; break; }
					if (level.map.get(w-1, 0) == OPEN) { closed = false; break; }
				}
			}
			if (!closed) errors.push("Error: Walls are not closed!");
			// Lights are useful to have
			if (!level.lights.length) errors.push("Warning: There are no lights in the level.");
			// Display check results to user
			if (errors.length) alert(errors.join('\n'));
		}

		function exportBase64() {
			prepareExport();
			var b64 = window.btoa(JSON.stringify(level, null));
			document.getElementById("exported").value = b64;
			document.getElementById("exported").style.display = "block";
		}

		function exportJSON() {
			prepareExport();
			document.getElementById("exported").value = JSON.stringify(level, null, '\t');
			document.getElementById("exported").style.display = "block";
		}

		function importLevel(json) {
			var json = json || prompt("Paste here the level JSON (can be base64) to import:");
			if (!json || !json.length) return;
			try {
				if (json[0] !== '{') json = window.atob(json);
				json = JSON.parse(json);
			} catch (err) {
				alert("Import error: " + err);
				return;
			}
			level = json;
			level.map = new Map(level.width, level.depth, level.map);
			w = level.width; h = level.depth;
			// Discard y-coordinates
			for (var i = 0; i < level.lights.length; ++i)
				if (level.lights[i].position.y !== undefined)
					delete level.lights[i].position.y

			document.getElementById("exported").value = "";
			document.getElementById("exported").style.display = "none";
		}

		function test() {
			var url = "../game_dev.html#level=" + window.btoa(JSON.stringify(level));
			window.open(url, "_blank");
		}

		var gui = new dat.GUI();
		gui.add(tools.walls, "drawWalls");
		gui.add(tools.diagonals, "placeDiagonalWalls");
		var guiMap = gui.addFolder("Map properties");
		guiMap.add(level.materials, "ceiling", materials);
		guiMap.add(level.materials, "wall", materials);
		guiMap.add(level.materials, "floor", materials);
		guiMap.add(level, "roomHeight", 2, 10).step(0.5);
		guiMap.add(level, "gridSize", 1, 4).step(1);
		guiMap.add(level, "startAngle", -135, 180).step(45);
		guiMap.add(tools.start, "placeStart");
		guiMap.add(tools.exit, "placeExit");
		var guiLights = gui.addFolder("Lights");
		guiLights.add(tools.light, "addLight");
		var guiObjects = gui.addFolder("Objects");
		guiObjects.add(tools.object, "object", objects).onChange(
			function() { currentTool = tools.object; });
		guiObjects.add(tools.object, "addObject");
		var guiEditor = gui.addFolder("Editor options");
		guiEditor.add(editor, "drawGrid");
		guiEditor.add(editor, "drawTextures");
		guiEditor.add(editor, "hideLights");
		guiEditor.add(editor, "hideObjects");
		gui.add(window, "importLevel");
		gui.add(window, "exportBase64");
		gui.add(window, "exportJSON");
		gui.add(window, "test");

		function mouseHandler(e) {
			e._x = e.layerX || e.offsetX || 0;
			e._y = e.layerY || e.offsetY || 0;
			if (currentTool[e.type]) currentTool[e.type](e);
			return false;
		}

		canvas.addEventListener("mousedown", mouseHandler, false);
		canvas.addEventListener("mouseup", mouseHandler, false);
		canvas.addEventListener("mousemove", mouseHandler, false);
		document.oncontextmenu = function() { return false; };
		window.addEventListener("load", render);

	</script>
</body>
</html>
